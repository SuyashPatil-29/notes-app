package services

import (
	"backend/pkg/recallai"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/openai/openai-go"
	openaioption "github.com/openai/openai-go/option"
	"github.com/rs/zerolog/log"
)

type AIService struct {
	client         *openai.Client
	apiKeyResolver APIKeyResolver
}

// TranscriptAnalysis represents the AI analysis result of a meeting transcript
type TranscriptAnalysis struct {
	NotebookName string   `json:"notebook_name"`
	ChapterName  string   `json:"chapter_name"`
	NoteName     string   `json:"note_name"`
	Summary      string   `json:"summary"`
	KeyPoints    []string `json:"key_points"`
	ActionItems  []string `json:"action_items"`
}

// TaskGenerationRequest represents a request to generate tasks from note content
type TaskGenerationRequest struct {
	NoteTitle   string  `json:"note_title"`
	NoteContent string  `json:"note_content"`
	UserID      string  `json:"user_id"`
	OrgID       *string `json:"org_id,omitempty"`
}

// GeneratedTask represents a single task generated by AI
type GeneratedTask struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Priority    string `json:"priority"` // "low", "medium", "high"
	Status      string `json:"status"`   // "todo", "in_progress", "done"
}

// TaskGenerationResponse represents the AI response for task generation
type TaskGenerationResponse struct {
	BoardName string          `json:"board_name"`
	Tasks     []GeneratedTask `json:"tasks"`
}

// NewAIService creates a new AI service instance
func NewAIService() *AIService {
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		log.Warn().Msg("OPENAI_API_KEY not set, AI analysis will be unavailable")
		return &AIService{
			client:         nil,
			apiKeyResolver: NewAPIKeyResolver(),
		}
	}

	client := openai.NewClient(openaioption.WithAPIKey(apiKey))

	return &AIService{
		client:         &client,
		apiKeyResolver: NewAPIKeyResolver(),
	}
}

// AnalyzeTranscript analyzes a meeting transcript and determines organizational structure
func (s *AIService) AnalyzeTranscript(ctx context.Context, transcript string, existingNotebooks []string) (*TranscriptAnalysis, error) {
	if s.client == nil {
		return nil, fmt.Errorf("OpenAI client not initialized - check OPENAI_API_KEY")
	}

	if strings.TrimSpace(transcript) == "" {
		return nil, fmt.Errorf("transcript cannot be empty")
	}

	notebooksStr := "None"
	if len(existingNotebooks) > 0 {
		notebooksJSON, _ := json.Marshal(existingNotebooks)
		notebooksStr = string(notebooksJSON)
	}

	systemPrompt := `You are an AI assistant that analyzes meeting transcripts and organizes them into a hierarchical note-taking structure.

Your task:
1. Analyze the meeting transcript
2. Determine appropriate Notebook, Chapter, and Note names
3. Create a concise summary
4. Extract key points and action items

Notebook: High-level category (e.g., "Work", "Personal", "Project X")
Chapter: Sub-category within notebook (e.g., "Q1 Planning", "Team Meetings")
Note: Specific meeting/topic (e.g., "Sprint Planning - Jan 15")

If the user has existing notebooks, try to fit the meeting into an existing notebook when appropriate.

Action Items: Extract specific tasks, follow-ups, or next steps mentioned in the meeting.

Respond ONLY with valid JSON in this exact format:
{
  "notebook_name": "string",
  "chapter_name": "string", 
  "note_name": "string",
  "summary": "string (2-3 sentences)",
  "key_points": ["point 1", "point 2", "point 3"],
  "action_items": ["action 1", "action 2", "action 3"]
}`

	userPrompt := fmt.Sprintf(`Existing notebooks: %s

Meeting Transcript:
%s

Analyze this transcript and provide the organizational structure and summary.`, notebooksStr, transcript)

	log.Info().
		Int("transcript_length", len(transcript)).
		Int("existing_notebooks_count", len(existingNotebooks)).
		Msg("Analyzing transcript with OpenAI")

	resp, err := s.client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model: openai.ChatModelGPT4o,

		MaxTokens:   openai.Int(1000),
		Temperature: openai.Float(0.3), // Lower temperature for more consistent results
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during transcript analysis")
		return nil, fmt.Errorf("openai API error: %w", err)
	}

	if len(resp.Choices) == 0 {
		return nil, fmt.Errorf("no response from OpenAI")
	}

	// Clean the response content - OpenAI sometimes wraps JSON in markdown code blocks
	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove markdown code block markers if present
	if strings.HasPrefix(content, "```json") {
		content = strings.TrimPrefix(content, "```json")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	var analysis TranscriptAnalysis
	if err := json.Unmarshal([]byte(content), &analysis); err != nil {
		log.Error().
			Err(err).
			Str("response_content", resp.Choices[0].Message.Content).
			Str("cleaned_content", content).
			Msg("Failed to parse AI response")
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}

	// Validate the analysis result
	if analysis.NotebookName == "" || analysis.ChapterName == "" || analysis.NoteName == "" {
		return nil, fmt.Errorf("AI analysis incomplete - missing required fields")
	}

	log.Info().
		Str("notebook_name", analysis.NotebookName).
		Str("chapter_name", analysis.ChapterName).
		Str("note_name", analysis.NoteName).
		Int("key_points_count", len(analysis.KeyPoints)).
		Msg("Successfully analyzed transcript")

	return &analysis, nil
}

// FormatTranscriptAsMarkdown converts a transcript and analysis into formatted markdown
func (s *AIService) FormatTranscriptAsMarkdown(transcript []recallai.TranscriptEntry, analysis *TranscriptAnalysis) string {
	if analysis == nil {
		return "# Meeting Transcript\n\n*Analysis unavailable*\n\n"
	}

	var md strings.Builder

	// Add title
	md.WriteString(fmt.Sprintf("# %s\n\n", analysis.NoteName))

	// Add summary section
	md.WriteString("## Summary\n\n")
	if analysis.Summary != "" {
		md.WriteString(analysis.Summary)
		md.WriteString("\n\n")
	} else {
		md.WriteString("*No summary available*\n\n")
	}

	// Add key points section
	if len(analysis.KeyPoints) > 0 {
		md.WriteString("## Key Points\n\n")
		for _, point := range analysis.KeyPoints {
			md.WriteString(fmt.Sprintf("- %s\n", point))
		}
		md.WriteString("\n")
	}

	// Add action items section
	if len(analysis.ActionItems) > 0 {
		md.WriteString("## Action Items\n\n")
		for _, item := range analysis.ActionItems {
			md.WriteString(fmt.Sprintf("- [ ] %s\n", item))
		}
		md.WriteString("\n")
	}

	// Add participants section if we have transcript data
	if len(transcript) > 0 {
		participants := s.extractParticipants(transcript)
		if len(participants) > 0 {
			md.WriteString("## Participants\n\n")
			for _, participant := range participants {
				hostIndicator := ""
				if participant.IsHost {
					hostIndicator = " (Host)"
				}
				md.WriteString(fmt.Sprintf("- %s%s\n", participant.Name, hostIndicator))
			}
			md.WriteString("\n")
		}
	}

	// Add full transcript section
	md.WriteString("## Full Transcript\n\n")

	if len(transcript) == 0 {
		md.WriteString("*No transcript data available*\n")
		return md.String()
	}

	// Add horizontal rule for visual separation
	md.WriteString("---\n\n")

	currentParticipant := ""
	var currentSentence strings.Builder

	for i, entry := range transcript {
		// Collect all words for this entry
		var words []string
		for _, word := range entry.Words {
			words = append(words, word.Text)
		}

		if len(words) == 0 {
			continue
		}

		entryText := strings.Join(words, " ")

		// Check if this is a new speaker
		if entry.Participant.Name != currentParticipant {
			// Write previous sentence if exists
			if currentSentence.Len() > 0 {
				md.WriteString(currentSentence.String())
				md.WriteString("\n\n")
				currentSentence.Reset()
			}

			// Add spacing between speakers (except for the first one)
			if currentParticipant != "" {
				md.WriteString("\n")
			}

			currentParticipant = entry.Participant.Name

			// Write speaker name with better formatting
			hostIndicator := ""
			if entry.Participant.IsHost {
				hostIndicator = " ðŸ‘¤"
			}
			md.WriteString(fmt.Sprintf("### %s%s\n\n", currentParticipant, hostIndicator))
		}

		// Add the text to current sentence
		currentSentence.WriteString(entryText)

		// Add space if not the last entry
		if i < len(transcript)-1 {
			currentSentence.WriteString(" ")
		}
	}

	// Write final sentence if exists
	if currentSentence.Len() > 0 {
		md.WriteString(currentSentence.String())
		md.WriteString("\n")
	}

	return md.String()
}

// extractParticipants extracts unique participants from the transcript
func (s *AIService) extractParticipants(transcript []recallai.TranscriptEntry) []recallai.ParticipantInfo {
	participantMap := make(map[int]recallai.ParticipantInfo)

	for _, entry := range transcript {
		if _, exists := participantMap[entry.Participant.ID]; !exists {
			participantMap[entry.Participant.ID] = entry.Participant
		}
	}

	participants := make([]recallai.ParticipantInfo, 0, len(participantMap))
	for _, participant := range participantMap {
		participants = append(participants, participant)
	}

	return participants
}

// TranscriptToPlainText converts transcript entries to plain text for AI analysis
func (s *AIService) TranscriptToPlainText(transcript []recallai.TranscriptEntry) string {
	var text strings.Builder

	for _, entry := range transcript {
		text.WriteString(fmt.Sprintf("%s: ", entry.Participant.Name))
		for _, word := range entry.Words {
			text.WriteString(word.Text)
			text.WriteString(" ")
		}
		text.WriteString("\n")
	}

	return text.String()
}

// CreateFallbackAnalysis creates a basic analysis when AI is unavailable
func (s *AIService) CreateFallbackAnalysis(meetingURL string) *TranscriptAnalysis {
	// Extract some basic info from the meeting URL if possible
	notebookName := "Meetings"
	chapterName := "Recorded Meetings"

	// Try to determine platform from URL
	platform := "Unknown Platform"
	if strings.Contains(meetingURL, "meet.google.com") {
		platform = "Google Meet"
	} else if strings.Contains(meetingURL, "zoom.us") {
		platform = "Zoom"
	} else if strings.Contains(meetingURL, "teams.microsoft.com") {
		platform = "Microsoft Teams"
	}

	// Create a basic note name with timestamp
	noteName := fmt.Sprintf("%s Meeting - %s", platform,
		fmt.Sprintf("%d", time.Now().Unix()))

	return &TranscriptAnalysis{
		NotebookName: notebookName,
		ChapterName:  chapterName,
		NoteName:     noteName,
		Summary:      "Meeting transcript processed without AI analysis.",
		KeyPoints:    []string{"Meeting recorded and transcribed", "AI analysis unavailable"},
	}
}

// GenerateTasksFromNote analyzes note content and generates relevant tasks
func (s *AIService) GenerateTasksFromNote(ctx context.Context, request TaskGenerationRequest) (*TaskGenerationResponse, error) {
	// Try to get API key using the resolver
	client, err := s.getClientForUser(request.UserID, request.OrgID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get OpenAI client for task generation")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	if strings.TrimSpace(request.NoteContent) == "" {
		return nil, fmt.Errorf("note content cannot be empty")
	}

	systemPrompt := `You are an AI assistant that analyzes note content and generates actionable tasks.

Your task:
1. Analyze the note content carefully
2. Extract actionable items, deliverables, and follow-up tasks
3. Create a meaningful task board name based on the note content
4. Generate specific, actionable tasks with appropriate priorities

Task Priority Guidelines:
- "high": Urgent tasks with deadlines or critical importance
- "medium": Important tasks that should be completed soon
- "low": Nice-to-have tasks or future considerations

Task Status Guidelines:
- "backlog": Future tasks or ideas for later consideration
- "todo": Tasks ready to be started
- "in_progress": Tasks currently being worked on (use sparingly)
- "done": Completed tasks (rarely used for new generation)

Generate 3-8 tasks maximum. Focus on quality over quantity.
Each task should be specific and actionable.
Default most tasks to "backlog" or "todo" status.

Respond ONLY with valid JSON in this exact format:
{
  "board_name": "string (descriptive name for the task board)",
  "tasks": [
    {
      "title": "string (concise task title)",
      "description": "string (detailed description of what needs to be done)",
      "priority": "high|medium|low",
      "status": "backlog|todo|in_progress|done"
    }
  ]
}`

	userPrompt := fmt.Sprintf(`Note Title: %s

Note Content:
%s

Analyze this note and generate relevant tasks that can be derived from the content. Focus on actionable items, follow-ups, deliverables, and next steps mentioned or implied in the note.`, request.NoteTitle, request.NoteContent)

	log.Info().
		Str("note_title", request.NoteTitle).
		Int("content_length", len(request.NoteContent)).
		Str("user_id", request.UserID).
		Msg("Generating tasks from note content")

	resp, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model:       openai.ChatModelGPT4o,
		MaxTokens:   openai.Int(1500),
		Temperature: openai.Float(0.3), // Lower temperature for more consistent results
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during task generation")
		// Return fallback response instead of error
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	if len(resp.Choices) == 0 {
		log.Warn().Msg("No response from OpenAI for task generation")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	// Clean the response content
	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove markdown code block markers if present
	if strings.HasPrefix(content, "```json") {
		content = strings.TrimPrefix(content, "```json")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	var taskResponse TaskGenerationResponse
	if err := json.Unmarshal([]byte(content), &taskResponse); err != nil {
		log.Error().
			Err(err).
			Str("response_content", resp.Choices[0].Message.Content).
			Str("cleaned_content", content).
			Msg("Failed to parse AI task generation response")
		// Return fallback response instead of error
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	// Validate the response
	if taskResponse.BoardName == "" {
		taskResponse.BoardName = fmt.Sprintf("%s - Tasks", request.NoteTitle)
	}

	// Validate and clean up tasks
	validTasks := make([]GeneratedTask, 0)
	for _, task := range taskResponse.Tasks {
		if task.Title == "" {
			continue
		}

		// Set default values if missing
		if task.Priority == "" {
			task.Priority = "medium"
		}
		if task.Status == "" {
			task.Status = "backlog"
		}

		// Validate priority and status values
		if task.Priority != "low" && task.Priority != "medium" && task.Priority != "high" {
			task.Priority = "medium"
		}
		if task.Status != "backlog" && task.Status != "todo" && task.Status != "in_progress" && task.Status != "done" {
			task.Status = "backlog"
		}

		validTasks = append(validTasks, task)
	}

	taskResponse.Tasks = validTasks

	// If no valid tasks were generated, create fallback
	if len(validTasks) == 0 {
		log.Warn().Msg("No valid tasks generated by AI, using fallback")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	log.Info().
		Str("board_name", taskResponse.BoardName).
		Int("tasks_count", len(validTasks)).
		Msg("Successfully generated tasks from note content")

	return &taskResponse, nil
}

// getClientForUser creates an OpenAI client using the appropriate API key for the user
func (s *AIService) getClientForUser(userID string, orgID *string) (*openai.Client, error) {
	// Try to get API key using the resolver
	keyResult, err := s.apiKeyResolver.GetAPIKey(userID, orgID, "openai")
	if err != nil {
		// Fall back to environment variable if no user/org key is configured
		apiKey := os.Getenv("OPENAI_API_KEY")
		if apiKey == "" {
			return nil, fmt.Errorf("no OpenAI API key available: %w", err)
		}

		log.Debug().
			Str("user_id", userID).
			Msg("Using environment OpenAI API key as fallback")

		client := openai.NewClient(openaioption.WithAPIKey(apiKey))
		return &client, nil
	}

	log.Debug().
		Str("user_id", userID).
		Str("key_source", string(keyResult.Source)).
		Msg("Using resolved OpenAI API key")

	client := openai.NewClient(openaioption.WithAPIKey(keyResult.APIKey))
	return &client, nil
}

// createFallbackTaskResponse creates a basic task response when AI is unavailable
func (s *AIService) createFallbackTaskResponse(noteTitle string) *TaskGenerationResponse {
	boardName := fmt.Sprintf("%s - Tasks", noteTitle)
	if noteTitle == "" {
		boardName = "Generated Tasks"
	}

	return &TaskGenerationResponse{
		BoardName: boardName,
		Tasks: []GeneratedTask{
			{
				Title:       "Review note content",
				Description: "Review and organize the information in this note",
				Priority:    "medium",
				Status:      "backlog",
			},
			{
				Title:       "Identify action items",
				Description: "Manually identify and create specific action items from the note content",
				Priority:    "medium",
				Status:      "backlog",
			},
		},
	}
}
