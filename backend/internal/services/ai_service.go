package services

import (
	"backend/pkg/recallai"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/openai/openai-go"
	openaioption "github.com/openai/openai-go/option"
	"github.com/rs/zerolog/log"
)

type AIService struct {
	client         *openai.Client
	apiKeyResolver APIKeyResolver
}

// TranscriptAnalysis represents the AI analysis result of a meeting transcript
type TranscriptAnalysis struct {
	NotebookName string   `json:"notebook_name"`
	ChapterName  string   `json:"chapter_name"`
	NoteName     string   `json:"note_name"`
	Summary      string   `json:"summary"`
	KeyPoints    []string `json:"key_points"`
	ActionItems  []string `json:"action_items"`
}

// TaskGenerationRequest represents a request to generate tasks from note content
type TaskGenerationRequest struct {
	NoteTitle   string  `json:"note_title"`
	NoteContent string  `json:"note_content"`
	UserID      string  `json:"user_id"`
	OrgID       *string `json:"org_id,omitempty"`
}

// GeneratedTask represents a single task generated by AI
type GeneratedTask struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Priority    string `json:"priority"` // "low", "medium", "high"
	Status      string `json:"status"`   // "todo", "in_progress", "done"
}

// TaskGenerationResponse represents the AI response for task generation
type TaskGenerationResponse struct {
	BoardName string          `json:"board_name"`
	Tasks     []GeneratedTask `json:"tasks"`
}

// NoteContentGenerationRequest represents a request to generate note content
type NoteContentGenerationRequest struct {
	NoteTitle   string  `json:"note_title"`
	Context     string  `json:"context,omitempty"`      // Optional: additional context
	ContentType string  `json:"content_type,omitempty"` // Optional: "outline", "detailed", "bullet_points"
	UserID      string  `json:"user_id"`
	OrgID       *string `json:"org_id,omitempty"`
}

// NewAIService creates a new AI service instance
func NewAIService() *AIService {
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		log.Warn().Msg("OPENAI_API_KEY not set, AI analysis will be unavailable")
		return &AIService{
			client:         nil,
			apiKeyResolver: NewAPIKeyResolver(),
		}
	}

	client := openai.NewClient(openaioption.WithAPIKey(apiKey))

	return &AIService{
		client:         &client,
		apiKeyResolver: NewAPIKeyResolver(),
	}
}

// AnalyzeTranscript analyzes a meeting transcript and determines organizational structure
func (s *AIService) AnalyzeTranscript(ctx context.Context, transcript string, existingNotebooks []string) (*TranscriptAnalysis, error) {
	if s.client == nil {
		return nil, fmt.Errorf("OpenAI client not initialized - check OPENAI_API_KEY")
	}

	if strings.TrimSpace(transcript) == "" {
		return nil, fmt.Errorf("transcript cannot be empty")
	}

	notebooksStr := "None"
	if len(existingNotebooks) > 0 {
		notebooksJSON, _ := json.Marshal(existingNotebooks)
		notebooksStr = string(notebooksJSON)
	}

	systemPrompt := `You are an AI assistant that analyzes meeting transcripts and organizes them into a hierarchical note-taking structure.

Your task:
1. Analyze the meeting transcript
2. Determine appropriate Notebook, Chapter, and Note names
3. Create a concise summary
4. Extract key points and action items

Notebook: High-level category (e.g., "Work", "Personal", "Project X")
Chapter: Sub-category within notebook (e.g., "Q1 Planning", "Team Meetings")
Note: Specific meeting/topic (e.g., "Sprint Planning - Jan 15")

If the user has existing notebooks, try to fit the meeting into an existing notebook when appropriate.

Action Items: Extract specific tasks, follow-ups, or next steps mentioned in the meeting.

Respond ONLY with valid JSON in this exact format:
{
  "notebook_name": "string",
  "chapter_name": "string", 
  "note_name": "string",
  "summary": "string (2-3 sentences)",
  "key_points": ["point 1", "point 2", "point 3"],
  "action_items": ["action 1", "action 2", "action 3"]
}`

	userPrompt := fmt.Sprintf(`Existing notebooks: %s

Meeting Transcript:
%s

Analyze this transcript and provide the organizational structure and summary.`, notebooksStr, transcript)

	log.Info().
		Int("transcript_length", len(transcript)).
		Int("existing_notebooks_count", len(existingNotebooks)).
		Msg("Analyzing transcript with OpenAI")

	resp, err := s.client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model: openai.ChatModelGPT4o,

		MaxTokens:   openai.Int(1000),
		Temperature: openai.Float(0.3), // Lower temperature for more consistent results
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during transcript analysis")
		return nil, fmt.Errorf("openai API error: %w", err)
	}

	if len(resp.Choices) == 0 {
		return nil, fmt.Errorf("no response from OpenAI")
	}

	// Clean the response content - OpenAI sometimes wraps JSON in markdown code blocks
	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove markdown code block markers if present
	if strings.HasPrefix(content, "```json") {
		content = strings.TrimPrefix(content, "```json")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	var analysis TranscriptAnalysis
	if err := json.Unmarshal([]byte(content), &analysis); err != nil {
		log.Error().
			Err(err).
			Str("response_content", resp.Choices[0].Message.Content).
			Str("cleaned_content", content).
			Msg("Failed to parse AI response")
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}

	// Validate the analysis result
	if analysis.NotebookName == "" || analysis.ChapterName == "" || analysis.NoteName == "" {
		return nil, fmt.Errorf("AI analysis incomplete - missing required fields")
	}

	log.Info().
		Str("notebook_name", analysis.NotebookName).
		Str("chapter_name", analysis.ChapterName).
		Str("note_name", analysis.NoteName).
		Int("key_points_count", len(analysis.KeyPoints)).
		Msg("Successfully analyzed transcript")

	return &analysis, nil
}

// FormatTranscriptAsMarkdown converts a transcript and analysis into formatted markdown
func (s *AIService) FormatTranscriptAsMarkdown(transcript []recallai.TranscriptEntry, analysis *TranscriptAnalysis) string {
	if analysis == nil {
		return "# Meeting Transcript\n\n*Analysis unavailable*\n\n"
	}

	var md strings.Builder

	// Add title
	md.WriteString(fmt.Sprintf("# %s\n\n", analysis.NoteName))

	// Add summary section
	md.WriteString("## Summary\n\n")
	if analysis.Summary != "" {
		md.WriteString(analysis.Summary)
		md.WriteString("\n\n")
	} else {
		md.WriteString("*No summary available*\n\n")
	}

	// Add key points section
	if len(analysis.KeyPoints) > 0 {
		md.WriteString("## Key Points\n\n")
		for _, point := range analysis.KeyPoints {
			md.WriteString(fmt.Sprintf("- %s\n", point))
		}
		md.WriteString("\n")
	}

	// Add action items section
	if len(analysis.ActionItems) > 0 {
		md.WriteString("## Action Items\n\n")
		for _, item := range analysis.ActionItems {
			md.WriteString(fmt.Sprintf("- [ ] %s\n", item))
		}
		md.WriteString("\n")
	}

	// Add participants section if we have transcript data
	if len(transcript) > 0 {
		participants := s.extractParticipants(transcript)
		if len(participants) > 0 {
			md.WriteString("## Participants\n\n")
			for _, participant := range participants {
				hostIndicator := ""
				if participant.IsHost {
					hostIndicator = " (Host)"
				}
				md.WriteString(fmt.Sprintf("- %s%s\n", participant.Name, hostIndicator))
			}
			md.WriteString("\n")
		}
	}

	// Add full transcript section
	md.WriteString("## Full Transcript\n\n")

	if len(transcript) == 0 {
		md.WriteString("*No transcript data available*\n")
		return md.String()
	}

	// Add horizontal rule for visual separation
	md.WriteString("---\n\n")

	currentParticipant := ""
	var currentSentence strings.Builder

	for i, entry := range transcript {
		// Collect all words for this entry
		var words []string
		for _, word := range entry.Words {
			words = append(words, word.Text)
		}

		if len(words) == 0 {
			continue
		}

		entryText := strings.Join(words, " ")

		// Check if this is a new speaker
		if entry.Participant.Name != currentParticipant {
			// Write previous sentence if exists
			if currentSentence.Len() > 0 {
				md.WriteString(currentSentence.String())
				md.WriteString("\n\n")
				currentSentence.Reset()
			}

			// Add spacing between speakers (except for the first one)
			if currentParticipant != "" {
				md.WriteString("\n")
			}

			currentParticipant = entry.Participant.Name

			// Write speaker name with better formatting
			hostIndicator := ""
			if entry.Participant.IsHost {
				hostIndicator = " ðŸ‘¤"
			}
			md.WriteString(fmt.Sprintf("### %s%s\n\n", currentParticipant, hostIndicator))
		}

		// Add the text to current sentence
		currentSentence.WriteString(entryText)

		// Add space if not the last entry
		if i < len(transcript)-1 {
			currentSentence.WriteString(" ")
		}
	}

	// Write final sentence if exists
	if currentSentence.Len() > 0 {
		md.WriteString(currentSentence.String())
		md.WriteString("\n")
	}

	return md.String()
}

// extractParticipants extracts unique participants from the transcript
func (s *AIService) extractParticipants(transcript []recallai.TranscriptEntry) []recallai.ParticipantInfo {
	participantMap := make(map[int]recallai.ParticipantInfo)

	for _, entry := range transcript {
		if _, exists := participantMap[entry.Participant.ID]; !exists {
			participantMap[entry.Participant.ID] = entry.Participant
		}
	}

	participants := make([]recallai.ParticipantInfo, 0, len(participantMap))
	for _, participant := range participantMap {
		participants = append(participants, participant)
	}

	return participants
}

// TranscriptToPlainText converts transcript entries to plain text for AI analysis
func (s *AIService) TranscriptToPlainText(transcript []recallai.TranscriptEntry) string {
	var text strings.Builder

	for _, entry := range transcript {
		text.WriteString(fmt.Sprintf("%s: ", entry.Participant.Name))
		for _, word := range entry.Words {
			text.WriteString(word.Text)
			text.WriteString(" ")
		}
		text.WriteString("\n")
	}

	return text.String()
}

// CreateFallbackAnalysis creates a basic analysis when AI is unavailable
func (s *AIService) CreateFallbackAnalysis(meetingURL string) *TranscriptAnalysis {
	// Extract some basic info from the meeting URL if possible
	notebookName := "Meetings"
	chapterName := "Recorded Meetings"

	// Try to determine platform from URL
	platform := "Unknown Platform"
	if strings.Contains(meetingURL, "meet.google.com") {
		platform = "Google Meet"
	} else if strings.Contains(meetingURL, "zoom.us") {
		platform = "Zoom"
	} else if strings.Contains(meetingURL, "teams.microsoft.com") {
		platform = "Microsoft Teams"
	}

	// Create a basic note name with timestamp
	noteName := fmt.Sprintf("%s Meeting - %s", platform,
		fmt.Sprintf("%d", time.Now().Unix()))

	return &TranscriptAnalysis{
		NotebookName: notebookName,
		ChapterName:  chapterName,
		NoteName:     noteName,
		Summary:      "Meeting transcript processed without AI analysis.",
		KeyPoints:    []string{"Meeting recorded and transcribed", "AI analysis unavailable"},
	}
}

// GenerateTasksFromNote analyzes note content and generates relevant tasks
func (s *AIService) GenerateTasksFromNote(ctx context.Context, request TaskGenerationRequest) (*TaskGenerationResponse, error) {
	// Try to get API key using the resolver
	client, err := s.getClientForUser(request.UserID, request.OrgID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get OpenAI client for task generation")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	if strings.TrimSpace(request.NoteContent) == "" {
		return nil, fmt.Errorf("note content cannot be empty")
	}

	systemPrompt := `You are an AI assistant that analyzes note content and generates actionable tasks.

Your task:
1. Analyze the note content carefully
2. Extract actionable items, deliverables, and follow-up tasks
3. Create a meaningful task board name based on the note content
4. Generate specific, actionable tasks with appropriate priorities

Task Priority Guidelines:
- "high": Urgent tasks with deadlines or critical importance
- "medium": Important tasks that should be completed soon
- "low": Nice-to-have tasks or future considerations

Task Status Guidelines:
- "backlog": Future tasks or ideas for later consideration
- "todo": Tasks ready to be started
- "in_progress": Tasks currently being worked on (use sparingly)
- "done": Completed tasks (rarely used for new generation)

Generate 3-8 tasks maximum. Focus on quality over quantity.
Each task should be specific and actionable.
Default most tasks to "backlog" or "todo" status.

Respond ONLY with valid JSON in this exact format:
{
  "board_name": "string (descriptive name for the task board)",
  "tasks": [
    {
      "title": "string (concise task title)",
      "description": "string (detailed description of what needs to be done)",
      "priority": "high|medium|low",
      "status": "backlog|todo|in_progress|done"
    }
  ]
}`

	userPrompt := fmt.Sprintf(`Note Title: %s

Note Content:
%s

Analyze this note and generate relevant tasks that can be derived from the content. Focus on actionable items, follow-ups, deliverables, and next steps mentioned or implied in the note.`, request.NoteTitle, request.NoteContent)

	log.Info().
		Str("note_title", request.NoteTitle).
		Int("content_length", len(request.NoteContent)).
		Str("user_id", request.UserID).
		Msg("Generating tasks from note content")

	resp, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model:       openai.ChatModelGPT4o,
		MaxTokens:   openai.Int(1500),
		Temperature: openai.Float(0.3), // Lower temperature for more consistent results
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during task generation")
		// Return fallback response instead of error
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	if len(resp.Choices) == 0 {
		log.Warn().Msg("No response from OpenAI for task generation")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	// Clean the response content
	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove markdown code block markers if present
	if strings.HasPrefix(content, "```json") {
		content = strings.TrimPrefix(content, "```json")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	var taskResponse TaskGenerationResponse
	if err := json.Unmarshal([]byte(content), &taskResponse); err != nil {
		log.Error().
			Err(err).
			Str("response_content", resp.Choices[0].Message.Content).
			Str("cleaned_content", content).
			Msg("Failed to parse AI task generation response")
		// Return fallback response instead of error
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	// Validate the response
	if taskResponse.BoardName == "" {
		taskResponse.BoardName = fmt.Sprintf("%s - Tasks", request.NoteTitle)
	}

	// Validate and clean up tasks
	validTasks := make([]GeneratedTask, 0)
	for _, task := range taskResponse.Tasks {
		if task.Title == "" {
			continue
		}

		// Set default values if missing
		if task.Priority == "" {
			task.Priority = "medium"
		}
		if task.Status == "" {
			task.Status = "backlog"
		}

		// Validate priority and status values
		if task.Priority != "low" && task.Priority != "medium" && task.Priority != "high" {
			task.Priority = "medium"
		}
		if task.Status != "backlog" && task.Status != "todo" && task.Status != "in_progress" && task.Status != "done" {
			task.Status = "backlog"
		}

		validTasks = append(validTasks, task)
	}

	taskResponse.Tasks = validTasks

	// If no valid tasks were generated, create fallback
	if len(validTasks) == 0 {
		log.Warn().Msg("No valid tasks generated by AI, using fallback")
		return s.createFallbackTaskResponse(request.NoteTitle), nil
	}

	log.Info().
		Str("board_name", taskResponse.BoardName).
		Int("tasks_count", len(validTasks)).
		Msg("Successfully generated tasks from note content")

	return &taskResponse, nil
}

// getClientForUser creates an OpenAI client using the appropriate API key for the user
func (s *AIService) getClientForUser(userID string, orgID *string) (*openai.Client, error) {
	// Try to get API key using the resolver
	keyResult, err := s.apiKeyResolver.GetAPIKey(userID, orgID, "openai")
	if err != nil {
		// Fall back to environment variable if no user/org key is configured
		apiKey := os.Getenv("OPENAI_API_KEY")
		if apiKey == "" {
			return nil, fmt.Errorf("no OpenAI API key available: %w", err)
		}

		log.Debug().
			Str("user_id", userID).
			Msg("Using environment OpenAI API key as fallback")

		client := openai.NewClient(openaioption.WithAPIKey(apiKey))
		return &client, nil
	}

	log.Debug().
		Str("user_id", userID).
		Str("key_source", string(keyResult.Source)).
		Msg("Using resolved OpenAI API key")

	client := openai.NewClient(openaioption.WithAPIKey(keyResult.APIKey))
	return &client, nil
}

// createFallbackTaskResponse creates a basic task response when AI is unavailable
func (s *AIService) createFallbackTaskResponse(noteTitle string) *TaskGenerationResponse {
	boardName := fmt.Sprintf("%s - Tasks", noteTitle)
	if noteTitle == "" {
		boardName = "Generated Tasks"
	}

	return &TaskGenerationResponse{
		BoardName: boardName,
		Tasks: []GeneratedTask{
			{
				Title:       "Review note content",
				Description: "Review and organize the information in this note",
				Priority:    "medium",
				Status:      "backlog",
			},
			{
				Title:       "Identify action items",
				Description: "Manually identify and create specific action items from the note content",
				Priority:    "medium",
				Status:      "backlog",
			},
		},
	}
}

// GenerateNoteContent generates content for a note based on its title and optional context
func (s *AIService) GenerateNoteContent(ctx context.Context, request NoteContentGenerationRequest) (string, error) {
	// Try to get API key using the resolver
	client, err := s.getClientForUser(request.UserID, request.OrgID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get OpenAI client for note content generation")
		return "", fmt.Errorf("AI service unavailable: %w", err)
	}

	if strings.TrimSpace(request.NoteTitle) == "" {
		return "", fmt.Errorf("note title cannot be empty")
	}

	// Default content type to "detailed" if not specified
	contentType := request.ContentType
	if contentType == "" {
		contentType = "detailed"
	}

	systemPrompt := `You are an AI assistant that helps users create comprehensive note content.

Your task:
1. Generate well-structured, informative content based on the note title
2. Make the content practical, actionable, and easy to understand
3. Use markdown formatting for better readability
4. Include relevant sections, lists, and examples where appropriate

Content should be:
- Clear and concise
- Well-organized with headers and sections
- Practical and actionable
- Formatted in markdown

IMPORTANT: Return ONLY the markdown content. Do NOT wrap it in code blocks or JSON.`

	var userPrompt string
	switch contentType {
	case "outline":
		userPrompt = fmt.Sprintf(`Create an outline for a note titled: "%s"

Include:
- Main sections and subsections
- Key topics to cover
- Important points to remember

%s`,
			request.NoteTitle,
			formatContextPrompt(request.Context))

	case "bullet_points":
		userPrompt = fmt.Sprintf(`Create bullet-point notes for: "%s"

Include:
- Key facts and information
- Important points
- Quick reference items

%s`,
			request.NoteTitle,
			formatContextPrompt(request.Context))

	default: // "detailed"
		userPrompt = fmt.Sprintf(`Create detailed note content for: "%s"

Include:
- Introduction
- Main sections with explanations
- Examples where relevant
- Key takeaways or summary

%s`,
			request.NoteTitle,
			formatContextPrompt(request.Context))
	}

	log.Info().
		Str("note_title", request.NoteTitle).
		Str("content_type", contentType).
		Str("user_id", request.UserID).
		Msg("Generating note content with AI")

	resp, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model:       openai.ChatModelGPT4o,
		MaxTokens:   openai.Int(2000),
		Temperature: openai.Float(0.7),
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during note content generation")
		return "", fmt.Errorf("failed to generate content: %w", err)
	}

	if len(resp.Choices) == 0 {
		return "", fmt.Errorf("no response from OpenAI")
	}

	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove any code block markers if AI wrapped the content
	if strings.HasPrefix(content, "```markdown") {
		content = strings.TrimPrefix(content, "```markdown")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	log.Info().
		Str("note_title", request.NoteTitle).
		Int("content_length", len(content)).
		Msg("Successfully generated note content")

	return content, nil
}

// formatContextPrompt formats the context string for the prompt
func formatContextPrompt(context string) string {
	if strings.TrimSpace(context) == "" {
		return ""
	}
	return fmt.Sprintf("\nAdditional context: %s", context)
}

// NoteOrganizationRequest represents a request to organize a note with AI
type NoteOrganizationRequest struct {
	NoteTitle         string   `json:"note_title"`
	ExistingNotebooks []string `json:"existing_notebooks,omitempty"`
	UserID            string   `json:"user_id"`
	OrgID             *string  `json:"org_id,omitempty"`
}

// NoteOrganizationResponse represents AI's decision on note organization
type NoteOrganizationResponse struct {
	NotebookName string `json:"notebook_name"`
	ChapterName  string `json:"chapter_name"`
}

// OrganizeNoteWithAI uses AI to determine the appropriate notebook and chapter for a note
func (s *AIService) OrganizeNoteWithAI(ctx context.Context, request NoteOrganizationRequest) (*NoteOrganizationResponse, error) {
	// Get appropriate API key
	client, err := s.getClientForUser(request.UserID, request.OrgID)
	if err != nil {
		return nil, err
	}

	systemPrompt := `You are an AI assistant that helps organize notes into notebooks and chapters.

Your task:
1. Analyze the note title
2. Suggest an appropriate notebook name (high-level category)
3. Suggest an appropriate chapter name (sub-category)

Guidelines:
- Keep names concise and clear
- Use title case for notebook and chapter names
- If existing notebooks are provided and one fits well, prefer it
- For work/professional notes: use notebooks like "Work", "Projects", "Meetings"
- For personal notes: use notebooks like "Personal", "Learning", "Ideas"
- For technical notes: use notebooks like "Development", "DevOps", "Documentation"
- Chapter should be more specific than notebook

Respond ONLY with valid JSON in this exact format:
{
  "notebook_name": "string",
  "chapter_name": "string"
}`

	existingNotebooksStr := ""
	if len(request.ExistingNotebooks) > 0 {
		existingNotebooksStr = fmt.Sprintf("\n\nExisting notebooks: %s", strings.Join(request.ExistingNotebooks, ", "))
	}

	userPrompt := fmt.Sprintf(`Organize this note:

Note title: "%s"%s

Provide the best notebook and chapter names.`, request.NoteTitle, existingNotebooksStr)

	log.Info().
		Str("note_title", request.NoteTitle).
		Str("user_id", request.UserID).
		Msg("Organizing note with AI")

	resp, err := client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.SystemMessage(systemPrompt),
			openai.UserMessage(userPrompt),
		},
		Model:       openai.ChatModelGPT4o,
		MaxTokens:   openai.Int(200),
		Temperature: openai.Float(0.7),
	})

	if err != nil {
		log.Error().Err(err).Msg("OpenAI API error during note organization")
		return nil, fmt.Errorf("failed to organize note: %w", err)
	}

	if len(resp.Choices) == 0 {
		return nil, fmt.Errorf("no response from OpenAI")
	}

	content := resp.Choices[0].Message.Content
	content = strings.TrimSpace(content)

	// Remove markdown code block markers if present
	if strings.HasPrefix(content, "```json") {
		content = strings.TrimPrefix(content, "```json")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	} else if strings.HasPrefix(content, "```") {
		content = strings.TrimPrefix(content, "```")
		content = strings.TrimSuffix(content, "```")
		content = strings.TrimSpace(content)
	}

	// Parse JSON response
	var organization NoteOrganizationResponse
	if err := json.Unmarshal([]byte(content), &organization); err != nil {
		log.Error().
			Err(err).
			Str("content", content).
			Msg("Failed to parse AI organization response")
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}

	log.Info().
		Str("note_title", request.NoteTitle).
		Str("notebook", organization.NotebookName).
		Str("chapter", organization.ChapterName).
		Msg("Successfully organized note with AI")

	return &organization, nil
}
